Angular

First Part

DÃ©couvrez le framework Angular

En bref,Â AngularÂ est unÂ framework JavaScriptÂ qui vous permet de dÃ©velopper des applications "efficaces et sophistiquÃ©es", comme dit la documentation. Il permet notamment de crÃ©er ce qu'on appelle desÂ Single Page ApplicationsÂ (ouÂ SPA)Â : des applicationsÂ entiÃ¨res qui tournent dans une seule page HTML grÃ¢ce au JavaScript.

Dev angulaire faire participer trois langages comme: HTML SCSS ET TYPESCRIPT

AngularÂ est un frameworkÂ complet, on peut crÃ©er des applications webÂ complÃ¨tes sansÂ avoir besoin de librairies tierces supplÃ©mentaires.

* LesÂ best practicesÂ (les bonnes pratiques) Angular sont extrÃªmement prÃ©cises â€“ les structures des applications Angular ont tendance Ã  se ressembler fortement, doncÂ il est facile de passer d'un projet Ã  un autre, et de s'assurer que son propre projet suit les meilleurs pratiques.
* Le framework a Ã©tÃ© conÃ§u pour fonctionner avec leÂ TypeScriptÂ â€“ il est tout Ã  fait possible d'utiliser le TypeScript pour React, Vue ou Svelte, mais Angular a Ã©tÃ© conÃ§u pour ce langage, donc son intÃ©gration est forcÃ©ment plus profonde.

RESUME
* Le framework Angular utiliseÂ le HTML, le SCSS et le TypeScript.
* Le TypeScript est un langage qui ajoute des syntaxes au JavaScript, notamment pour le typage strict.

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

Installez les dÃ©pendances

Il vous faudra quelques outils indispensables pour du dÃ©veloppement Angular en toute tranquillitÃ© comme NPM, NODE et aprÃ¨s installer le CLI angular
npm i -g @angular/cli
After installation
Ng v


Angular fonctionne sur tous les navigateurs modernes.

En rÃ©sumÃ©

* Pour installer le CLI d'Angular, il vous faut une version LTS de Node et npm.
* On installe le CLI avec la commande Â npm i -g @angular/cli
* On peut vÃ©rifier la version installÃ©e du CLI avec Â ng v
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

Construisez une application Angular avec le CLI


Depuis une ligne de commande, naviguez dans le dossier oÃ¹ vous souhaitez crÃ©er votre projet Angular, et exÃ©cutez la commande suivanteÂ :
ng new snapface --style=scss --skip-tests=true

La commande Â ng newÂ  gÃ©nÃ¨re une nouvelle application Angular, installe les dÃ©pendances du projet, et initialise un dÃ©pÃ´t Git. Le flag Â --style=scssÂ  dit au CLI que vous souhaitez utiliser le SCSS pour les styles (plutÃ´t que le CSS ou le LESS, par exemple), et le flag Â --skip-tests=trueÂ  dit que vous ne voulez pas gÃ©nÃ©rer de fichiers de tests unitaires pour ce projet.

Pour lancer lâ€™app on nâ€™a cette commande:
 ng serve

Port: 4200

En rÃ©sumÃ©

* Une nouvelle application Angular se crÃ©e avec Â ng new
* ng serveÂ  exÃ©cute le serveur de dÃ©veloppement.
* La balise Â <app-root>Â  correspond Ã  AppComponent.

Second Part

Construire votre premier component

Le motÂ componentÂ en anglais signifie "composant", et Ã  juste titreÂ : les components sont lesÂ composants de baseÂ d'une application Angular.

Il n'y a pas de rÃ¨gle d'or dans le dÃ©coupage d'une application en componentsÂ : onÂ essaieÂ d'Ã©quilibrerÂ entre ne pas avoir un trop grand nombre de components, et avoir quand mÃªme des components simples et pas trop gros.


Le CLI d'Angular propose des commandes de crÃ©ation pour faciliter le dÃ©veloppement, et vous allez en utiliser une maintenant, depuis une ligne de commande dans le dossier du projetÂ :

ng generate component face-snap

UnÂ dÃ©corateurÂ en TypeScript permet, entre autres, d'apporter desÂ modificationsÂ Ã  une classe. Ici, le dÃ©corateur Â @ComponentÂ  vient ajouter tous les comportements nÃ©cessaires Ã  l'utilisation de ce component dans l'application. Il est importÃ© depuis le package Â @angular/core

En rÃ©sumÃ©

* Une application Angular peut Ãªtre vue comme une arborescence de components.
* Un component lie un template HTML et des styles SCSS Ã  du comportement TS.
* Pour crÃ©er un component, on utilise la commande Â ng generate componentÂ nom-du-component
* Le sÃ©lecteur d'un component correspond Ã  la balise HTML personnalisÃ©e qu'on utilisera pour l'insÃ©rer dans l'application.

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”


Affichez des donnÃ©es

En Angular, il y a deux faÃ§ons principales d'exploiter une donnÃ©e venant du TypeScript dans le templateÂ : laÂ string interpolationÂ et la liaison par attribut, ouÂ attribute binding. Mais pour afficher des donnÃ©es, il faut d'abord des donnÃ©esÂ !
`
Comme vous pouvez le constater, on crÃ©e un attribut de classe en associant leÂ nomÂ de l'attribut Ã  sonÂ type.

Pour initialiser ces propriÃ©tÃ©sÂ en suivant les best practices Angular, vous allez utiliser la mÃ©thode Â ngOnInit()Â  (que vous aviez supprimÃ©e prÃ©cÃ©demment). Pour l'utiliser, votre component doit implÃ©menter l'interface Â OnInit

La mÃ©thode Â ngOnInit()Â  est appelÃ©e automatiquement par Angular au moment de laÂ crÃ©ation de chaque instanceÂ du component. Elle permet notamment d'initialiser des propriÃ©tÃ©s.

LaÂ string interpolationÂ est la mÃ©thode la plus simple pour afficher le contenu d'une variable dans le template. Il suffitÂ de mettre le nom de la variable Ã  afficher entreÂ doubles accoladesÂ {{ }}Â dans le HTML .


En rÃ©sumÃ©

* On dÃ©clare les propriÃ©tÃ©s d'un component en haut de sa classe, et on les initialise dans la mÃ©thode Â ngOnInit()
* La mÃ©thode Â ngOnInit()Â  est appelÃ©e une fois par instance de component au moment de la crÃ©ation de cette instance.
* La string interpolation avec les doubles accolades Â {{ }}Â  permet d'insÃ©rer la valeur d'une propriÃ©tÃ© TypeScript dans le template.
* L'attribute binding permet de lier la valeur d'une propriÃ©tÃ© TypeScript Ã  un attribut HTML, en mettant l'attribut entre crochets Â []Â  et en passant le nom de la propriÃ©tÃ©.

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

RÃ©agissez aux Ã©vÃ©nements

Le nom de mÃ©thodeÂ qui commence parÂ onÂ signale que cette mÃ©thode rÃ©pond Ã  un Ã©vÃ©nement.
Il faut maintenantÂ lierÂ cette mÃ©thode au clic sur le bouton avec la liaison par Ã©vÃ©nement, ouÂ event binding. LÃ  oÃ¹ vous avez utilisÃ© des crochets pour lier aux attributs, vous allez utiliser desÂ parenthÃ¨sesÂ Â ()Â  pour lier aux Ã©vÃ©nementsÂ :

<button (click)="onAddSnap()">Oh Snap!</button>

Prenons quelques instants pour noter que chaqueÂ instanceÂ d'un component est totalementÂ indÃ©pendante.Â 

En rÃ©sumÃ©

* Pour lier une mÃ©thode Ã  un Ã©vÃ©nement d'un Ã©lÃ©ment du template, mettez l'Ã©vÃ©nement entreÂ parenthÃ¨sesÂ Â ()Â  et passez la mÃ©thode en argument ; ex. :Â (click)="onClickButton()"


â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

Ajoutez des propriÃ©tÃ©s personnalisÃ©es


 AngularÂ vous permet d'ajouter desÂ propriÃ©tÃ©s personnalisÃ©esÂ Ã  vos components de maniÃ¨re Ã  ce que vous puissiez les injecterÂ depuis le component parent.


Pour qu'une propriÃ©tÃ© puisse Ãªtre injectÃ©eÂ depuis l'extÃ©rieurÂ d'un component, il faut lui ajouter le dÃ©corateur Â @Input(). CrÃ©ez maintenant une propriÃ©tÃ© Â faceSnapÂ  de type Â FaceSnapÂ  (votre nouveau typeÂ !) et mettez-lui ce dÃ©corateurÂ :

@Input() faceSnap!: FaceSnap;


InputÂ  doit Ãªtre ajoutÃ© aux imports depuis Â @angular/coreÂ  !

Vous allez maintenant utiliser l'attribute bindingÂ pour lier cet objet Ã  la propriÃ©tÃ© personnalisÃ©e Â faceSnapÂ  de FaceSnapComponent dans Â app.component.htmlÂ  :

<app-face-snap [faceSnap]="mySnap"></app-face-snap>


Comme vous pouvez le remarquer, la nouvelle propriÃ©tÃ© Â faceSnapÂ  est utilisÃ©eÂ comme toute autre propriÃ©tÃ©.


En rÃ©sumÃ©

* N'hÃ©sitez pas Ã  crÃ©er vos propres types, sous forme de classe par exemple, pour faciliter la manipulation de donnÃ©es dans votre application.
* Une propriÃ©tÃ© personnalisÃ©e est rendue injectable depuis l'extÃ©rieur grÃ¢ce au dÃ©corateur Â @Input()
* Une propriÃ©tÃ© en Â @Input()Â  est utilisable comme n'importe quelle autre propriÃ©tÃ©Â : on peutÂ en afficher les Ã©lÃ©ments, les modifierâ€¦Â 
* On lie ensuite une valeur Ã  cette propriÃ©tÃ© depuis le component parent avec l'attribute binding, c'est-Ã -dire le nom de la propriÃ©tÃ© entre crochets Â []Â  en passant la valeur entre les guillemets ; ex. :Â [faceSnap]="mySnap".



Thirst Part

Conditionner lâ€™affichage des Ã©lÃ©ments

UneÂ directiveÂ est une classe qui vientÂ ajouter du comportementÂ Ã  l'Ã©lÃ©ment sur lequel elle est posÃ©e. L'astÃ©risque au dÃ©but du nom Â *ngIfÂ  nous montre qu'il s'agit d'une directiveÂ structurelle, qui viendra donc toucher Ã  la structure du document.

On passe Ã  Â *ngIfÂ  la condition selon laquelle l'Ã©lÃ©ment doit Ãªtre ajoutÃ©. Ici, Angular Ã©value Â faceSnap.locationÂ  comme Ã©tantÂ "truthy"Â quand la propriÃ©tÃ© existe et qu'elle ne contient pas la chaÃ®ne vide (ou les valeurs Â null, Â false, ou Â 0, mais il s'agit ici d'une string). Elle est Ã©valuÃ©e comme Ã©tantÂ "falsey"Â quand la propriÃ©tÃ© retourne undefined, c'est-Ã -dire quand elle n'existe pas.


pour afficher uniquement les photos prises Ã  Paris. On peut mÃªme mettre la directive Â *ngIfÂ  sur des components. Dans Â app.component.html, on pourrait imaginer un filtre pour montrer uniquement les FaceSnaps ayant plus de 5 Â snapsÂ  :

<app-face-snap [faceSnap]="mySnap" *ngIf="mySnap.snaps > 5"></app-face-snap>

<app-face-snap [faceSnap]="myOtherSnap" *ngIf="myOtherSnap.snaps > 5"></app-face-snap>

<app-face-snap [faceSnap]="myLastSnap" *ngIf="myLastSnap.snaps > 5"></app-face-snap>


En rÃ©sumÃ©

* Vous pouvez ajouter des propriÃ©tÃ©s optionnelles Ã  une classe en y ajoutant un point d'interrogation Â ?
* Ajouter la directive Â *ngIfÂ  Ã  un Ã©lÃ©ment (qui peut aussi Ãªtre un component) dit Ã  AngularÂ d'ajouter ou non cet Ã©lÃ©ment au DOM selon la condition que vous lui passez, par exempleÂ Â <p *ngIf="size === 'large'">
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
Afficher des listes

Dans une application web dynamique, il n'est gÃ©nÃ©ralement pas possible de prÃ©voir en avance le nombre d'Ã©lÃ©ments qu'il y aura dans une liste de donnÃ©es retournÃ©e par le serveur. Il va souvent vous les renvoyer sous forme deÂ tableauÂ (ouÂ Array, en anglais), et ce sera Ã Â vous d'arriver Ã  afficher la liste en entier, qu'il y ait un Ã©lÃ©ment ou milleÂ !Â Vous devrez doncÂ itÃ©rerÂ sur un tableau pour y arriver, et c'est lÃ  oÃ¹ intervient la directive*ngFor.


â€˜ngâ€™ est un prÃ©fixe commun utilisÃ© dans les commandes de la ligne de commande pour les projets Angular. Il est souvent utilisÃ© pour exÃ©cuter diverses tÃ¢ches de dÃ©veloppement telles que la crÃ©ation de composants, de services, de modules, de directives, de pipes, etc. Il s'agit d'une abrÃ©viation de "Angular" et est utilisÃ© pour dÃ©signer les outils de la ligne de commande d'Angular.
En utilisant les outils de ligne de commande â€˜ngâ€™, les dÃ©veloppeurs peuvent automatiser et simplifier certaines tÃ¢ches courantes de dÃ©veloppement telles que la gÃ©nÃ©ration de code et la gestion des dÃ©pendances. Les commandes â€˜ngâ€™ sont souvent utilisÃ©es dans des environnements de dÃ©veloppement tels que le terminal de commandes, le shell, ou les scripts de construction automatisÃ©s.
Par exemple, â€˜ngâ€™ serve lance un serveur de dÃ©veloppement pour l'application Angular, ng generate component gÃ©nÃ¨re un nouveau composant Angular, ng build compile l'application pour la production, etc.


Au lieu d'avoir trois variables de type Â FaceSnapÂ  dans votre AppComponent, vous allez crÃ©er une seule variable qui contiendra un tableau de type Â FaceSnap[]Â  et modifier votre Â ngOnInit()


Maintenant, dans le template, auÂ lieu d'insÃ©rer plusieurs instances de Â <app-face-snap>Â , vous allez utiliser le code suivantÂ :

<app-face-snap *ngFor="let faceSnap of faceSnaps" [faceSnap]="faceSnap"></app-face-snap>
Regardons de plus prÃ¨s ce qui se passe exactement avec cette syntaxeÂ :
* la directive Â *ngForÂ  fonctionne un peu comme une boucle Â for...ofÂ  , c'est-Ã -dire que, dans ce cas de figure, elle va itÃ©rer sur le tableau Â faceSnapsÂ  et vous exposerÂ l'Ã©lÃ©mentÂ correspondant Ã  chaque itÃ©ration sous l'alias Â faceSnap
* vous associez ensuite l'Ã©lÃ©ment du tableau Ã  la propriÃ©tÃ© Â faceSnapÂ  du component.

Rien ne vous empÃªche d'utiliser des alias comme Ã§a dans vos applications, mais on prÃ©fÃ©rera gÃ©nÃ©ralement la version plus courte. Vous utiliserez trÃ¨s souvent Â *ngFor, donc vous prendrez vite l'habitudeÂ !


En rÃ©sumÃ©

* La directive Â *ngForÂ  vousÂ permet d'insÃ©rer un Ã©lÃ©ment dans le DOM pour chaque Ã©lÃ©ment dans un tableau.
* La syntaxe Â let element of arrayÂ  vous donne accÃ¨s Ã  l'Ã©lÃ©ment de chaque itÃ©ration, vous permettant de l'injecter dans un component, par exemple.

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
Ajoutez du style dynamique

La fonctionnalitÃ© que je vous propose d'ajouter maintenant est que plus un FaceSnap a de "snaps", plus le nombre de "snaps" sera colorÃ©Â en vert. Pour ceci, vous allez utiliser la directive[ngStyle]

Je vous encourage Ã  crÃ©er vos propres styles ici. Si jamais vous souhaitez continuer le cours sans le faire, je vous partage une idÃ©e. Vous pouvez remplacer le contenu deÂ face-snap.component.scss


La directive Â [ngStyle]Â  prendra comme argument un objet oÃ¹Â :
* lesÂ clÃ©sÂ sont les styles CSS Ã  modifier ;
* lesÂ valeursÂ sont les valeurs que doivent prendre ces styles.

Pour utiliser directement le nombre de snaps comme valeur pour le vert de la couleur de texte, vous pouvezÂ utiliser la fonction CSS Â rgb()Â  :

<span [ngStyle]="{ color: 'rgb(0, ' + faceSnap.snaps + ', 0)' }">ğŸ¤Œ {{ faceSnap.snaps }}</span>

En rÃ©sumÃ©

* La directive Â [ngStyle]Â  permet d'appliquer des styles qui dÃ©pendent de valeurs dynamiques, comme un texte qui, plus il y a de snaps, devient de plus en plus vert.
* La directive Â [ngStyle]Â  prend comme argument un objet oÃ¹ les clÃ©s correspondent aux styles CSS Ã  modifier, et les valeurs aux valeurs que doivent prendre ces styles.

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
Mettez de la classe
L'objectif de ce chapitre est de faire ressortir visuellement les FaceSnaps que l'utilisateur a "snapped". On pourraÂ imaginer une classeÂ snappedÂ  qui viendra s'ajouter Ã  la Â <div class="face-snap-card">Â  pour modifier quelques couleurs, par exemple. On ajoute cette classe dans Â face-snap.component.scss



Maintenant, il va falloir appliquer cette classeÂ conditionnellement. Je vais vous expliquer le fonctionnement de la directive Â [ngClass]Â  et vous laisser essayer d'implÃ©menter la fonctionnalitÃ© recherchÃ©e.
[ngClass]Â  prend un objet en argument, comme Â [ngStyle], mais dont le fonctionnement est diffÃ©rentÂ :
* lesÂ clÃ©sÂ sont lesÂ noms de classe CSSÂ Ã  appliquer ;
* lesÂ valeursÂ sont lesÂ conditionsÂ qui doivent Ãªtre remplies pour que les classes correspondantes s'appliquent.
En gros :

<div [ngClass]="{ 'class-name': condition }"></div>

<div class="face-snap-card" [ngClass]="{ snapped: buttonText === 'Oops, unSnap!' }">


En rÃ©sumÃ©

* La directive Â [ngClass]Â  permet d'ajouter dynamiquement des classes Ã  des Ã©lÃ©ments HTML.
* [ngClass]Â  prend un objet en argument oÃ¹ les clÃ©s sont des noms de classe CSS, et les valeurs sont les conditions selon lesquelles les classes doivent Ãªtre appliquÃ©es.




* Vous avez dÃ©couvert les directives : des classes qui permettent d'ajouter des comportements Ã  des Ã©lÃ©ments HTML, ou mÃªme Ã  des components.
* Vous avez implÃ©mentÃ© des directives structurelles pour modifier la structure du documentÂ :
    * *ngIfÂ  pour ajouter un Ã©lÃ©ment ou non au DOM selon une condition donnÃ©e ;
    * *ngForÂ  pour ajouter autant d'Ã©lÃ©ments au DOM qu'il y a d'Ã©lÃ©ments dans un tableau.
* Vous avez utilisÃ© des directives par attribut pour gÃ©rer dynamiquement les stylesÂ :
    * [ngStyle]Â  pour paramÃ©trer des styles selon desÂ valeurs venant du TypeScript ;
    * [ngClass]Â  pour ajouter et retirer des classes CSS selon une condition donnÃ©e.



Fourth part

Changez la casse

AngularÂ vous fournit un type d'outil puissant pour ce cas de figure : lesÂ pipes. Un pipe est appliquÃ© dans le HTML et vaÂ formaterÂ la valeur qu'on lui passe selon le pipe utilisÃ©Â sans toucher Ã  la donnÃ©e sous-jacente. Dans ce chapitre, vous verrez quelques pipes qui existent pour changer la casse d'une chaÃ®ne de caractÃ¨res.

Il existe trois pipes fournis par Angular pour modifier la casse :
* LowerCasePipeÂ : on afficheÂ le texte enÂ minuscules
* UpperCasePipeÂ : on affiche le texte enÂ majuscules
* TitleCasePipeÂ : on affiche le texte avec une majuscule au dÃ©but de chaque mot, avec le reste du mot en minuscules

On applique un pipe Ã  une chaÃ®ne de caractÃ¨res affichÃ©e avec la string interpolation. On rajoute le caractÃ¨re pipe Â |Â  puis le nom du pipe. Par exemple, si vous voulez afficher le titre des FaceSnap en majuscules, vous appliquez UpperCasePipe :

<h2>{{ faceSnap.title | uppercase }}</h2>


De mÃªme pour LowerCasePipe et TitleCasePipe :

<h2>{{ faceSnap.title | lowercase }}</h2>

<h2>{{ faceSnap.title | titlecase }}</h2>

Les pipesÂ existent uniquement pour modifier leÂ formatage affichÃ©Â d'une donnÃ©e : on ne peut pas les utiliser ailleurs que dans le template, et il estÂ fortement dÃ©conseillÃ©Â de les utiliser ailleurs que dans une string interpolation.

En rÃ©sumÃ©

* Un pipe permet de formater l'affichage d'une donnÃ©e sans modifier la donnÃ©e sous-jacente.
* Angular fournit trois pipes pour modifier la casse affichÃ©e d'une chaÃ®ne de caractÃ¨resÂ : UpperCasePipe, LowerCasePipe, et TitleCasePipe pour les majuscules, les minuscules et le mÃ©lange type "titre".

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
Formatez les dates

Vous allez maintenant personnaliser ce formatage pour amÃ©liorer l'expÃ©rience de vos utilisateurs avecÂ DatePipe.

Il est tout Ã  fait possible d'utiliser DatePipe comme vous avez utilisÃ© UpperCasePipe prÃ©cÃ©demment, et un formatageÂ par dÃ©fautÂ sera appliquÃ©Â :

<p>Mis en ligne le {{ faceSnap.createdDate | date }}</p>

date: 'longDate'
date: 'dd/MM/yy, Ã  HH:mm'
date: 'Ã  HH:mm, le d MMMM yyyy'

En rÃ©sumÃ©

* DatePipe permet de formater les dates, et sans configuration fournit un formatage par dÃ©faut.
* DatePipe fournit des configurationsÂ prÃ©dÃ©finies avec des noms comme Â short, Â longDateÂ  ou Â mediumTime
* DatePipe permet Ã©galement de personnaliser totalement le format d'affichage des dates avec des chaÃ®nes de caractÃ¨res qui encodent le format souhaitÃ©, par exempleÂ Â 'Ã  HH:mm, le d MMMM yyyy'
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
Formatez les chiffres

Dans le cadre de ce cours, je voudrais partager avec vous une derniÃ¨re catÃ©gorie de pipesÂ : ceux qui concernent le formatage desÂ nombresÂ selon les rÃ¨gles de locale de l'application. Il y en a troisÂ :
* DecimalPipeÂ â€“ facilite l'affichage de nombres avec desÂ chiffres aprÃ¨s la virguleÂ (qui met une virgule plutÃ´t qu'un point, par exemple).
* PercentPipeÂ â€“ formate les chiffres enÂ pourcentage.
* CurrencyPipeÂ â€“ permet d'afficher des nombres sous forme deÂ monnaieÂ trÃ¨s facilement.

Pour la dÃ©monstration des pipes liÃ©s aux nombres, ajoutez simplement un paragraphe contenant unÂ nombre. Il faut que ce nombre soit entreÂ doubles accoladesÂ pour que vous puissiez y attribuer un pipe (et aussi pour qu'il soit considÃ©rÃ© de type Â number



Si vous avez modifiÃ© la locale de votre application pour la passer en franÃ§ais, regardez ce qui se passe quand vous ajoutezÂ DecimalPipeÂ avec le mot-clÃ© Â numberÂ  :


<p>{{ 4346234.36 | number }}</p>

<p>{{ 4346234.36 | number: '1.0-0' }}</p>

La configuration signifie :
* au moins un chiffre pour les entiers ;
* minimum 0 chiffres aprÃ¨s la virgule â€“ maximum 0 chiffres (Angular arrondira donc Ã  l'entier le plus proche).

PercentPipeÂ arrondit par dÃ©fautÂ les pourcentages Ã  l'entier le plus proche. Vous pouvez cependant le configurerÂ de la mÃªme maniÃ¨re que DecimalPipeÂ :

<p>{{ 0.336 | percent: '1.0-1' }}</p>


Quand les nombres dans votre application correspondent Ã  desÂ montants d'argent, CurrencyPipe facilite leur affichage. Si vous utilisez l'affichage par dÃ©fautÂ :Â 

<p>{{ 344.36 | currency }}</p>



Vous pouvez passer unÂ deuxiÃ¨me argumentÂ qui permet d'afficher le code de la monnaie plutÃ´t que son symbole. Pour passer un deuxiÃ¨me argument Ã  un pipe, on remet un deux-points Â :Â  et on passe le deuxiÃ¨meÂ argumentÂ :

<p>{{ 344.36 | currency: 'EUR' : 'code' }}</p>




En rÃ©sumÃ©

* DecimalPipe (mot-clÃ© Â numberÂ ) vous permet d'afficher un nombre selon les rÃ¨gles de la locale de l'application.
* PercentPipe affiche un nombre entre 0 et 1 sous forme de pourcentage, arrondi par dÃ©faut Ã  l'entier le plus proche.
* DecimalPipe et PercentPipe acceptent un argument de configuration sous la formeÂ 'chiffresMinAvantVirgule.chiffresMinAprÃ¨sVirgule-chiffresMaxAprÃ¨sVirgule'Â ex. : Â '1.0-1'
* CurrencyPipe facilite l'affichage des montants d'argent, et accepte plusieurs arguments de configuration sÃ©parÃ©s par des deux-points Â :


Qu'avez-vous appris dans cette partie du cours ?

* Vous avez dÃ©couvert les pipes â€“ des outils pour gÃ©rer le format d'affichage d'une donnÃ©e sans modifier la donnÃ©e elle-mÃªme.
* Vous avez changÃ© la casse de vos chaÃ®nes de caractÃ¨res avec UpperCasePipe, LowerCasePipe et TitleCasePipe.
* Vous avez modifiÃ© l'affichage de la date de crÃ©ation des FaceSnaps avec DatePipe, et vous avez vu les diffÃ©rentes maniÃ¨res de personnaliser l'affichage des dates en passant un argument de configuration Ã  DatePipe.
* Vous avez manipulÃ© le format d'affichage des nombres avec DecimalPipe, PercentPipe et CurrencyPipe.



PART FIVE

Partagez des donnÃ©es avec les Services


Dans une application complÃ¨te Angular, vous aurez des dizaines, voire des centaines de components diffÃ©rents. Ces components auront trÃ¨s souvent besoin d'accÃ©der auxÂ mÃªmes donnÃ©es. Il y aura desÂ interactionsÂ courantes avec ces donnÃ©es, comme l'Ã©criture, la modification et la suppression. L'application peut Ã©galement avoir besoin d'interagir avec unÂ serveurÂ concernant ces donnÃ©es, pour la lecture et l'enregistrement.Â 

Pour mieuxÂ organiserÂ votre code, pourÂ Ã©viter de rÃ©pÃ©terÂ des blocs et pour toujours avoir des donnÃ©esÂ Ã  jourÂ partout dans l'application, ce serait intÃ©ressant de pouvoir regrouper les donnÃ©es et leurs mÃ©thodes ensemble, de lesÂ centraliser. En Angular, cette centralisation se fait dans desÂ services.


Un service est une classe, et la faÃ§on la plus simple de dÃ©clarer une classe comme Ã©tant un service est d'utiliser le dÃ©corateur Â @Injectable()Â  qui s'importe depuis Â @angular/core


L'objet de configuration qui spÃ©cifie Â providedIn: 'root'Â  dit Ã  Angular d'enregistrer ce service Ã  laÂ racineÂ de l'application. Ce sera trÃ¨s souvent le cas pour vos services, car Ã§a permet de s'assurer de n'avoir qu'une seule instanceÂ du service,Â partagÃ©eÂ par tous les partis intÃ©ressÃ©s.



Le premier Ã©lÃ©ment que vous allez dÃ©porter dans votre service est le tableau des FaceSnaps. Il est important de savoir qu'un service n'aÂ pas de mÃ©thode Â ngOnInit(), car les services ne sont pas instanciÃ©s de la mÃªme maniÃ¨re que les components.


Pour pouvoir utiliser un service dans un component, il faut utiliser le systÃ¨me d'injection de dÃ©pendancesÂ (dependency injection ouÂ DI)Â que vousÂ fournit Angular. C'est trÃ¨s simpleÂ : vousÂ passez un argument du type du service au constructor du component, et Angular vous mettra Ã  disposition la bonne instance du service.


import { FaceSnapsService } from '../services/face-snaps.service';
//...
constructor(private faceSnapsService: FaceSnapsService) { }

Pour rappel, ajouter unÂ modificateur d'accÃ¨sÂ comme Â publicÂ  ou Â privateÂ  Ã  un argument du Â constructorÂ  crÃ©e une propriÃ©tÃ©Â avec ce nom-lÃ  dans la classe. Vous aurez donc accÃ¨s au service via la propriÃ©tÃ© Â faceSnapsService.


Maintenant que vous avez accÃ¨s au service, vous pouvez modifierÂ l'initialisation de la propriÃ©tÃ© Â faceSnapsÂ  du component pour y attribuer leÂ tableau du serviceÂ :

ngOnInit(): void {

    this.faceSnaps = this.faceSnapsService.faceSnaps;

}


En rÃ©sumÃ©

* LesÂ services permettent de centraliser les donnÃ©es et la logique pour les diffÃ©rents domaines de votre application.
* CrÃ©er un service est aussi simple qu'ajouter le dÃ©corateur Â @Injectable()Â  Ã  une classe.
* Pour injecter un service dans un component, ajoutez un argument au constructor du component qui a le type du service, par exempleÂ private userService: UserService

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
Centralisez votre logique avec les Services

Cependant, dans une application totalement dynamique, on peut imaginer que ces FaceSnaps viendraient d'unÂ serveur, ou d'une autre partie de l'application, et qu'il faudrait appeler uneÂ mÃ©thodeÂ pour les rÃ©cupÃ©rer. D'ailleurs, toute modification d'un FaceSnap entraÃ®nerait Ã©galement un appel au serveur.

Il faudra doncÂ centraliserÂ toutes lesÂ interactionsÂ avec les FaceSnaps dans FaceSnapsService, et c'est exactement ce que vous allez faire maintenantÂ !


La premiÃ¨re mÃ©thode que vous allez crÃ©er est Â getAllFaceSnaps(). Cette mÃ©thode retournera, comme son nom l'indique, tous les FaceSnaps contenus dans le service.

Il s'agit d'une mÃ©thode TypeScript, donc il est vivement conseillÃ© de stipuler sonÂ type de retourÂ â€“ ici, il s'agit d'un tableau de Â FaceSnapÂ  :

getAllFaceSnaps(): FaceSnap[] {

    return this.faceSnaps;

}


Pour l'instant, vous n'avez aucun moyenÂ d'identifierÂ un FaceSnap directement. Ajoutez dÃ¨s maintenant une propriÃ©tÃ© obligatoire Â idÂ  de type Â numberÂ  Ã  votre modÃ¨le FaceSnapÂ 

Et ajoutez un Â idÂ  diffÃ©rent Ã  chacun des FaceSnaps dans votre service, par exemple


Cette mÃ©thode :
* cherche un FaceSnap par son Â idÂ  dans le tableau faceSnaps avec la fonction Â find()Â  ;
* si le FaceSnap existe, on lui incrÃ©mente ses Â snapsÂ  ;
* sinon, on Â throwÂ  une erreur.


En rÃ©sumÃ©

* CentraliserÂ les interactions dans un service sous forme de mÃ©thodes crÃ©e une structure plus modulaire, qui facilite la maintenance et les Ã©volutions de votre application.
* Comme dans toute base de code, refactorisez pour Ã©viter de rÃ©pÃ©ter des blocs de code (le principe DRYÂ :Â Don't Repeat Yourself).
* Les literal types permettent de crÃ©er rapidement des types personnalisÃ©s, souvent utilisÃ©s pour limiter les choix pour un argument de mÃ©thode, par exemple :Â fileType: 'image' | 'video'
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”


Passez en SPA avec le routing


LesÂ Single Page ApplicationsÂ (ouÂ SPA) sont de plus en plus courantes dans le monde du dÃ©veloppement web moderne. Elles permettent uneÂ performanceÂ sans Ã©gale en enlevant le besoin d'une application de demander, recevoir, puis afficher une nouvelle page HTML Ã  chaque changement d'URL. Angular vous permet avec leÂ routingÂ de crÃ©er ce genre d'applicationÂ â€“ Ã  chaqueÂ URLÂ correspondra unÂ component, et Angular remplacera le component actif sansÂ Ã©mettre de requÃªte au serveur.


En rÃ©sumÃ©

* Un module de routing contient un tableau de type Â RoutesÂ  qui contient les routes de l'application.
* Une route est un objet de type Â { path: 'myPath', component: MyComponent }Â  qui spÃ©cifie le component Ã  afficher pour chaque route.
* On appelle Â RouterModule.forRoot()Â  en passant le tableau de routes pour enregistrer les routes dans le routeur Angular.
* On enregistre le module de routing dans AppModule pour ajouter le routeur configurÃ© Ã  l'application.
* On ajoute une balise Â <router-outlet>Â  pour dire Ã  quel niveau du template le component de la route active doit Ãªtre insÃ©rÃ©.
* Pour ajouter des fichiers statiques Ã  une application (comme des images), on les stocke dans le dossier Â assetsÂ  .




